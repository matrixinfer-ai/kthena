/*
Copyright The Volcano Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package plugins

/*
Prefix Cache Plugin Design

Overview:
The Prefix Cache Plugin is a scoring plugin for the kthena router scheduler that implements a prefix-based matching mechanism
for model inference requests. It helps optimize pod scheduling by identifying pods that have previously processed similar
prompts, potentially improving inference performance through cache hits.

Key Components:

1. PrefixCache
   - Main plugin struct implementing the framework.ScorePlugin interface
   - Manages the caching mechanism for model inference requests
   - Configurable parameters for block size and maximum blocks to match

2. ModelPrefixStore
   - Three-level map structure: model -> hash -> pod
   - The LRU cache is used to record hashes. The evicted hash will also be remove from the three-level map above synchronously.
   - During the matching process, only the topK pods with the longest matching prefixes will be returned.

Core Features:

1. Prefix Matching
   - Divides prompts into fixed-size blocks (default: 64 bytes)
   - Generates rolling hashes for each block using xxHash algorithm
   - Each hash is generated by combining the previous block's hash with the current block's content
   - This creates a chain of dependencies where each hash implicitly contains information about all previous blocks
   - When matching hashes, we can start from the end and work backwards:
     * If a hash matches, it guarantees that all previous blocks also match
     * This property allows for efficient prefix matching without checking each block individually
     * The matching length is determined by the position of the first matching hash

2. Scoring Mechanism
   - Scores pods based on the length of matching prefixes
   - Score range: 0-100, calculated as (matching blocks / total blocks) * 100
   - Higher scores indicate better cache hit potential

3. Cache Management
   - LRU-based eviction policy for memory efficiency
   - Automatic cleanup of evicted entries
   - Configurable cache capacity and top-K results

Usage:
The plugin is used in the kthena router scheduler framework to score pods based on their potential
for cache hits. It's particularly useful for inference workloads where similar prompts are
likely to be processed multiple times.

Configuration Parameters:
- BlockSizeToHash: Size of each block for hashing (default: 64 bytes)
- MaxBlocksToMatch: Maximum number of blocks to process (default: 128), longer prompts are not processed
- Cache capacity and top-K results are configurable (default: 1000 and 5 respectively)

*/

import (
	"fmt"

	"github.com/cespare/xxhash"
	"github.com/stretchr/testify/assert/yaml"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/klog/v2"

	"github.com/volcano-sh/kthena/pkg/infer-router/datastore"
	"github.com/volcano-sh/kthena/pkg/infer-router/scheduler/framework"
	"github.com/volcano-sh/kthena/pkg/infer-router/scheduler/plugins/cache"
	"github.com/volcano-sh/kthena/pkg/infer-router/utils"
)

const PrefixCachePluginName = "prefix-cache"

var _ framework.ScorePlugin = &PrefixCache{}

type PrefixCache struct {
	name string

	blockSizeToHash  int
	maxBlocksToMatch int
	store            *cache.ModelPrefixStore
}

type PrefixCacheArgs struct {
	BlockSizeToHash  int `yaml:"blockSizeToHash,omitempty"`
	MaxBlocksToMatch int `yaml:"maxBlocksToMatch,omitempty"`
	MaxHashCacheSize int `yaml:"maxHashCacheSize,omitempty"`
}

// Default token block size of vLLM is 16, and a good guess of average characters per token is 4.
// So we use 64 as the default block size.
func NewPrefixCache(store datastore.Store, pluginArg runtime.RawExtension) *PrefixCache {
	var prefixCacheArgs PrefixCacheArgs
	if yaml.Unmarshal(pluginArg.Raw, &prefixCacheArgs) != nil {
		klog.Errorf("Unmarshal PrefixCacheArgs error, setting default value")
		prefixCacheArgs = PrefixCacheArgs{
			64,
			128,
			50000,
		}
	}

	p := &PrefixCache{
		name: PrefixCachePluginName,

		blockSizeToHash:  prefixCacheArgs.BlockSizeToHash,
		maxBlocksToMatch: prefixCacheArgs.MaxBlocksToMatch,
	}
	// Initialize store with default values
	p.store = cache.NewModelPrefixStore(store, prefixCacheArgs.MaxHashCacheSize, 5) // TODO: make these configurable
	return p
}

func (p *PrefixCache) Name() string {
	return p.name
}

func (p *PrefixCache) Score(ctx *framework.Context, pods []*datastore.PodInfo) map[*datastore.PodInfo]int {
	// Hash the prompt
	hashes := p.hashPrompt(ctx.Model, utils.GetPromptString(ctx.Prompt))
	if len(hashes) == 0 {
		return nil
	}

	scoreResults := make(map[*datastore.PodInfo]int, len(pods))
	// Store hashes in context for later use in PostSchedule
	ctx.Hashes = hashes

	// Find pods with matching prefixes
	matches := p.store.FindTopMatches(ctx.Model, hashes, pods)

	podMap := make(map[types.NamespacedName]*datastore.PodInfo, len(pods))
	for _, pod := range pods {
		podMap[types.NamespacedName{Namespace: pod.Pod.Namespace, Name: pod.Pod.Name}] = pod
	}

	// Calculate scores based on prefix match length
	totalHashes := len(hashes)
	for _, match := range matches {
		// Score is the ratio of matching hashes to total hashes, scaled to 0-100
		score := int((float64(match.MatchLen) / float64(totalHashes)) * 100)
		pod := podMap[match.NamespacedName]
		if pod == nil {
			klog.Errorf("Pod %s not found in pod map, this maybe because of prefix cache state inconsistency", match.NamespacedName)
			continue
		}
		scoreResults[pod] = score
	}

	return scoreResults
}

func (p *PrefixCache) PostSchedule(ctx *framework.Context, index int) {
	if ctx.BestPods != nil {
		// Add the best pod to the cache
		p.store.Add(ctx.Model, ctx.Hashes, ctx.BestPods[index])
		return
	}

	if index < len(ctx.DecodePods) && ctx.DecodePods[index] != nil && len(ctx.Hashes) > 0 {
		// Add the selected pod and its hashes to the cache
		p.store.Add(ctx.Model, ctx.Hashes, ctx.DecodePods[index])
	}

	if index < len(ctx.PrefillPods) && ctx.PrefillPods[index] != nil && len(ctx.Hashes) > 0 {
		// Add the selected pod and its hashes to the cache
		p.store.Add(ctx.Model, ctx.Hashes, ctx.PrefillPods[index])
	}
}

func (p *PrefixCache) hashPrompt(model string, prompt string) []uint64 {
	res := []uint64{}
	if len(prompt) == 0 {
		return res
	}

	// Initialize first block hash
	// Use model name as the first hash to avoid hash collision
	var prevHash uint64 = xxhash.Sum64([]byte(model))
	blockStart := 0

	// Process blocks up to maxBlocksToMatch or until we run out of prompt
	for i := 0; i < p.maxBlocksToMatch && blockStart < len(prompt); i++ {
		// Calculate end position for current block
		blockEnd := blockStart + p.blockSizeToHash
		if blockEnd > len(prompt) {
			blockEnd = len(prompt)
		}

		// Get current block content and combine with previous hash
		block := prompt[blockStart:blockEnd]
		data := []byte(fmt.Sprintf("%d%s", prevHash, block))

		// Use xxHash algorithm
		currHash := xxhash.Sum64(data)

		// Append hash to results
		res = append(res, currHash)

		// Update for next iteration
		prevHash = currHash
		blockStart = blockEnd

		// Break if we've reached the end of prompt
		if blockEnd == len(prompt) {
			break
		}
	}

	return res
}
